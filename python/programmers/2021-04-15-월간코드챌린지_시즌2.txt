어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요.

제한사항
absolutes의 길이는 1 이상 1,000 이하입니다.
absolutes의 모든 수는 각각 1 이상 1,000 이하입니다.
signs의 길이는 absolutes의 길이와 같습니다.
signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다.
입출력 예
absolutes	signs	result
[4,7,12]	[true,false,true]	9
[1,2,3]	[false,false,true]	0


다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

(), [], {} 는 모두 올바른 괄호 문자열입니다.
만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.
만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.
대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x < (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
s의 길이는 1 이상 1,000 이하입니다.
입출력 예
s	result
"[](){}"	3
"}]()[{"	2
"[)(]"	0
"}}}"	0


각 점에 가중치가 부여된 트리가 주어집니다. 당신은 다음 연산을 통하여, 이 트리의 모든 점들의 가중치를 0으로 만들고자 합니다.

임의의 연결된 두 점을 골라서 한쪽은 1 증가시키고, 다른 한쪽은 1 감소시킵니다.
하지만, 모든 트리가 위의 행동을 통하여 모든 점들의 가중치를 0으로 만들 수 있는 것은 아닙니다. 당신은 주어진 트리에 대해서 해당 사항이 가능한지 판별하고, 만약 가능하다면 최소한의 행동을 통하여 모든 점들의 가중치를 0으로 만들고자 합니다.

트리의 각 점의 가중치를 의미하는 1차원 정수 배열 a와 트리의 간선 정보를 의미하는 edges가 매개변수로 주어집니다. 주어진 행동을 통해 트리의 모든 점들의 가중치를 0으로 만드는 것이 불가능하다면 -1을, 가능하다면 최소 몇 번만에 가능한지를 찾아 return 하도록 solution 함수를 완성해주세요. (만약 처음부터 트리의 모든 정점의 가중치가 0이라면, 0을 return 해야 합니다.)

제한사항
a의 길이는 2 이상 300,000 이하입니다.
a의 모든 수는 각각 -1,000,000 이상 1,000,000 이하입니다.
a[i]는 i번 정점의 가중치를 의미합니다.
edges의 행의 개수는 (a의 길이 - 1)입니다.
edges의 각 행은 [u, v] 2개의 정수로 이루어져 있으며, 이는 u번 정점과 v번 정점이 간선으로 연결되어 있음을 의미합니다.
edges가 나타내는 그래프는 항상 트리로 주어집니다.
입출력 예
a	edges	result
[-5,0,2,1,2]	[[0,1],[3,4],[2,3],[0,3]]	9
[0,1,0]	[[0,1],[1,2]]	-1


당신은 어떤 RPG 게임의 주인공입니다. 게임에는 n개의 도시(0번, 1번, ..., n-1번)와 m개의 도시 간 도로, 그리고 상수값 z가 있습니다. 각 도로는 일방통행이며, 도로마다 다른 가중치값 w (이 w는 z보다 항상 작습니다)를 가지고 있습니다.

당신은 게임 도중 매 턴당 다음 행동 중 하나를 취할 수 있습니다.

현재 있는 도시에서 연결된 도로를 따라 다른 도시로 이동합니다. 해당 도로의 가중치값을 w라고 할 때, w원을 얻습니다.
현재 있는 도시에서 움직이지 않고 z원을 얻습니다.
원하는 아무 도시로 순간 이동합니다. 이때 얻는 돈은 없습니다.
여기서 주의해야 할 점은, 같은 도로를 몇 번을 사용하든 그 도로를 사용할 때마다 얻는 금액은 동일하다는 것입니다.

이때, 당신에게 q개의 쿼리가 주어집니다. 각 쿼리는 단일 숫자 c로 이루어져 있으며, 당신은 이 게임을 0번 도시에서 0원을 가진 상태에서 시작했을 때, 정확히 c원을 얻는 것이 가능한지, 가능하다면 최소 몇 턴만에 c원을 얻을 수 있는지를 판별해야 합니다.

도시의 숫자 n, 게임의 상수값 z, 도시 간 도로의 정보 roads, 그리고 쿼리들로 이루어진 배열 queries가 매개변수로 주어집니다. 주어진 정보들을 활용하여 각 쿼리의 답(불가능한 경우 -1)을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
n은 2 이상 3,000 이하입니다.
z는 2 이상 50 이하입니다.
roads의 길이는 1 이상 3,000 이하입니다.
roads의 각 행은 [u, v, w] 3개의 정수로 이루어져 있으며, 이는 u번 도시부터 v번 도시까지 도로가 연결되어 있고, 해당 도로를 따라 이동했을 때 w원을 얻을 수 있음을 의미합니다.
0 ≤ u, v < n 입니다.
1 ≤ w < z 입니다.
u랑 v는 서로 다른 수입니다.
u번 도시에서 v번 도시로 가는 도로는 최대 하나뿐입니다.
queries의 길이는 1 이상 100,000 이하입니다.
queries의 모든 숫자는 0 이상 1018 이하입니다.
입출력 예
n	z	roads	queries	result
5	5	[[1,2,3],[0,3,2]]	[0,1,2,3,4,5,6]	[0,-1,1,2,3,1,4]


